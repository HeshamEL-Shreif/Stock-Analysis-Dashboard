from dash import Dash, dcc, html, Input, Output, State, ctx
import dash_bootstrap_components as dbc
from dash.dependencies import Input, Output
import plotly.express as px
import pandas as pd
import yfinance as yf
import dash
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from sklearn.linear_model import LinearRegression
import numpy as np
from prophet import Prophet
from UI.ui import color

def get_header(ticker):
    logo = {
        "AAPL": "assets/icons8-apple-logo.svg",
        "MSFT": "assets/icons8-microsoft.svg",
        "GOOGL": "assets/icons8-google-logo.svg",
        "AMZN": "assets/icons8-amazon.svg",
        "TSLA": "assets/icons8-tesla.svg",
        "META": "assets/icons8-meta.svg"
    }

    ticker_name = {
        "AAPL": "Apple",
        "MSFT": "Microsoft",
        "GOOGL": "Google",
        "AMZN": "Amazon",
        "TSLA": "Tesla",
        "META": "Meta"
    }

    left_content = html.Div([
        html.Img(src=logo[ticker], style={"width": "40px", "height": "40px", "marginRight": "10px"}),
        html.H1(f"{ticker_name.get(ticker, ticker)} Stock", style={"color": "black", "margin": 0, "fontSize": "28px"})
    ], style={"display": "flex", "alignItems": "center"})

 

    return left_content

def get_numbers_bar(ticker, revenue, net_income, profit_margin, fcf, eps, pe, dividend):
    
    
    numbers_bar_style = {
    "fontSize": "24px",
    "color": color[ticker][0],
    "margin": "0"
    }
    text_style = {
        'fontSize': '12px'
    }
    
    bar_row = dbc.Row([
        dbc.Col([
            html.H5(revenue, id='revenue-kpi', style=numbers_bar_style),
            html.H6('Revenue', style=text_style),
            dbc.Tooltip("Total annual revenue generated by the company.", target='revenue-kpi')
        ], style={'textAlign': 'center'}),

        dbc.Col([
            html.H5(net_income, id='net-income-kpi', style=numbers_bar_style),
            html.H6('Net Income', style=text_style),
            dbc.Tooltip("Net profit after all expenses, taxes, and costs.", target='net-income-kpi')
        ], style={'textAlign': 'center'}),

        dbc.Col([
            html.H2(profit_margin, id='profit-margin-kpi', style=numbers_bar_style),
            html.H6('Profit Margin', style=text_style),
            dbc.Tooltip("Profit Margin = Net Income รท Revenue.", target='profit-margin-kpi')
        ], style={'textAlign': 'center'}),

        dbc.Col([
            html.H2(fcf, id='fcf-kpi', style=numbers_bar_style),
            html.H6('FCF', style=text_style),
            dbc.Tooltip("Free Cash Flow: Cash available after capital expenditures.", target='fcf-kpi')
        ], style={'textAlign': 'center'}),

        dbc.Col([
            html.H2(eps, id='eps-kpi', style=numbers_bar_style),
            html.H6('EPS', style=text_style),
            dbc.Tooltip("Earnings Per Share: Net income divided by total shares.", target='eps-kpi')
        ], style={'textAlign': 'center'}),

        dbc.Col([
            html.H2(pe, id='pe-kpi', style=numbers_bar_style),
            html.H6('PE', style=text_style),
            dbc.Tooltip("Price-to-Earnings Ratio: Stock price รท EPS.", target='pe-kpi')
        ], style={'textAlign': 'center'}),

        dbc.Col([
            html.H2(dividend, id='dividend-kpi', style=numbers_bar_style),
            html.H6('Dividend', style=text_style),
            dbc.Tooltip("Dividend yield: Percentage of earnings returned to shareholders.", target='dividend-kpi')
        ], style={'textAlign': 'center'}),
    ],
        style={
            'width': '100%',
            'display': 'flex',
            'alignItems': 'center',
            'justifyContent': 'space-between',
            'padding': '10px 20px',
            'marginTop':'20px'
        }
    )
    return bar_row


def get_stock_plot(df, ticker_string):
    
    open = round(df[f'Open_{ticker_string}'].iloc[-1], 2)
    close = round(df[f'Close_{ticker_string}'].iloc[-1], 2)
    low = round(df[f'Low_{ticker_string}'].iloc[-1], 2)
    high = round(df[f'High_{ticker_string}'].iloc[-1], 2)

    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=df['Date'], y=df[f'Open_{ticker_string}'], mode='lines', name='Open',
        line=dict(color=color[ticker_string][1]), visible=True
    ))
    fig.add_trace(go.Scatter(
        x=df['Date'], y=df[f'Close_{ticker_string}'], mode='lines', name='Close',
        line=dict(color=color[ticker_string][2]), visible=False
    ))
    fig.add_trace(go.Scatter(
        x=df['Date'], y=df[f'High_{ticker_string}'], mode='lines', name='High',
        line=dict(color=color[ticker_string][3]), visible=False
    ))
    fig.add_trace(go.Scatter(
        x=df['Date'], y=df[f'Low_{ticker_string}'], mode='lines', name='Low',
        line=dict(color=color[ticker_string][4]), visible=False
    ))

    def get_button(label, visibility, title, annotation_text):
        return dict(
            label=label,
            method="update",
            args=[
                {"visible": visibility},
                {
                    "title": {
                        "text": f"Stock Price: {title}",
                        "x": 0.5, "xanchor": "center",
                        "font": {"size": 17, "color": "rgba(0,0,0,0.6)"}
                    },
                    "annotations": [
                        dict(
                            text=f"{annotation_text} ",
                            x=0.5, y=0.5, xref="paper", yref="paper",
                            showarrow=False,
                            font=dict(size=25, color='rgba(0, 0, 0, 0.5)'),
                            xanchor="center"
                        )
                    ]
                }
            ]
        )

    fig.update_layout(
        updatemenus=[
            dict(
                type="buttons",
                direction="right",
                buttons=[
                    get_button("Open", [True, False, False, False], "Open", open),
                    get_button("Close", [False, True, False, False], "Close", close),
                    get_button("High", [False, False, True, False], "High", high),
                    get_button("Low", [False, False, False, True], "Low", low),
                ],
                pad={"r": 5, "t": 5},
                showactive=True,
                x=0.9, xanchor="center",
                y=1.32, yanchor="top",
                font=dict(size=12)
            )
        ],
        title=dict(
            text="Stock Price: Open", x=0.5, y=0.9, xanchor='center',
            font=dict(size=17, color='rgba(0, 0, 0, 0.6)')
        ),
        font=dict(size=17),
        xaxis_title=dict(text="Date", font=dict(size=12)),
        yaxis_title=dict(text="Price (USD)", font=dict(size=12)),
        height=300,
        paper_bgcolor='white',
        plot_bgcolor='white',
        margin=dict(l=20, r=10, t=60, b=40),
        xaxis=dict(
            tickfont=dict(size=11),
            showgrid=True, gridcolor='lightgrey',
            rangeslider=dict(visible=True, thickness=0.05),
            rangeselector=dict(
                buttons=[
                    dict(count=1, label="1m", step="month", stepmode="backward"),
                    dict(count=6, label="6m", step="month", stepmode="backward"),
                    dict(count=1, label="YTD", step="year", stepmode="todate"),
                    dict(count=1, label="1y", step="year", stepmode="backward"),
                    dict(step="all")
                ],
                x=0.1, xanchor="center",
                y=1.2, yanchor="top",
                font=dict(size=8)
            )
        ),
        yaxis=dict(
            tickfont=dict(size=11),
            showgrid=True, gridcolor='lightgrey'
        )
    )

    fig.add_annotation(
        text=f'{open}', xref="paper", yref="paper",
        x=0.5, y=0.5, showarrow=False,
        font=dict(size=25, color='rgba(0, 0, 0, 0.5)'),
        xanchor='center'
    )
    plot = dcc.Graph(figure=fig)
    stock_plots = dbc.Col(plot, width=12)

    row_1 = dbc.Row([stock_plots], style={'display': 'flex', 'alignItems': 'center', 'justifyContent': 'space-around', 'flexWrap': 'nowrap', 'margin':'10px 50px 10px 50px'})

    return row_1


def get_forecast_plot(ticker_string, forecast_data, prophet_df):

    forecasted_only = forecast_data[forecast_data['ds'] > prophet_df['ds'].max()]

    forcast_fig = go.Figure()
    
    forcast_fig.add_traces([
        go.Scatter(
            x=forecasted_only['ds'], y=forecasted_only['yhat_upper'],
            line=dict(width=0), showlegend=False
        ),
        go.Scatter(
            x=forecasted_only['ds'], y=forecasted_only['yhat_lower'],
            fill='tonexty', fillcolor=color[ticker_string][7],
            line=dict(width=0), showlegend=False
        )
    ])

    forcast_fig.add_trace(go.Scatter(
        x=forecasted_only['ds'], y=forecasted_only['yhat'],
        name='Forecast', line=dict(color=color[ticker_string][5])
    ))

    forcast_fig.add_trace(go.Scatter(
        x=forecasted_only['ds'], y=forecasted_only['yhat_upper'],
        name='Upper Bound', line=dict(dash='dot', color=color[ticker_string][6])
    ))

    forcast_fig.add_trace(go.Scatter(
        x=forecasted_only['ds'], y=forecasted_only['yhat_lower'],
        name='Lower Bound', line=dict(dash='dot', color=color[ticker_string][6])
    ))

    forcast_fig.update_layout(
        xaxis_title=dict(text="Date", font=dict(size=12)),
        yaxis_title=dict(text="Predicted Price (USD)", font=dict(size=12)),
        template="plotly_white",
        margin=dict(l=50, r=20, t=40, b=10), 
        height=240,
        legend=dict(
            orientation='h',
            x=0,
            y=1.,
            traceorder='normal',
            font=dict(size=10)
        ),
    )


    forcast_fig.add_annotation(
        text=f"Forcasting",
        xref="paper", yref="paper",
        x=0.5, y=1.25,
        showarrow=False,
        font=dict(size=25),
        xanchor='center'
    )



    plot = dcc.Graph(figure=forcast_fig)
    return plot

def get_forecast_gauge(ticker_string, prophet_df, forecast_data):

    last_actual_date = prophet_df['ds'].max()
    last_actual_price = prophet_df.loc[prophet_df['ds'] == last_actual_date, 'y'].values[0]

    tomorrow_date = last_actual_date + pd.Timedelta(days=1)
    tomorrow_forecast = forecast_data[forecast_data['ds'] == tomorrow_date]

    if not tomorrow_forecast.empty:
        predicted_price = tomorrow_forecast['yhat'].values[0]
        percent_change = ((predicted_price - last_actual_price) / last_actual_price) * 100
    else:
        percent_change = 0 

    fig = go.Figure(go.Indicator(
        mode="gauge+number+delta",
        value=percent_change,
        delta={
            "reference": 0,
            "increasing": {"color": color[ticker_string][8]},
            "decreasing": {"color": color[ticker_string][9]}
        },
        gauge={
            "axis": {"range": [-10, 10], "tickwidth": 1, "tickcolor": 'darkgrey'},
            'bar': {'color': color[ticker_string][10]},
            "bgcolor": "white",
            "steps": [
                {"range": [-10, 0], "color":  color[ticker_string][11]},
                {"range": [0, 10], "color":  color[ticker_string][12]}
            ],
            "threshold": {
                "line": {"color": "black", "width": 4},
                "thickness": 0.75,
                "value": percent_change
            }
        },
        domain={"x": [0, 1], "y": [0.15, 1]}
    ))

    fig.add_annotation(
        text="Predicted % Change Tomorrow",
        x=0.5, y=0.05,
        xref="paper", yref="paper",
        showarrow=False,
        font={"size": 12},
        xanchor="center"
    )

    fig.update_layout(
        margin=dict(t=40, b=40, l=40, r=40),
        height=240
    )

    return dcc.Graph(figure=fig)



def plot_cumulative_returns(ticker_string, combined):

    combined.columns = [f'{ticker_string} Cumulative', 'S&P 500 Cumulative']

    df_melted = combined.reset_index().melt(id_vars='Date', var_name='Index', value_name='Cumulative Return')

    custom_colors = [color[ticker_string][13], color[ticker_string][14]]  # Example: blue for ticker, orange for S&P 500

    # Create the plot
    fig = px.line(df_melted, x='Date', y='Cumulative Return', color='Index',
                  color_discrete_sequence=custom_colors)

    fig.update_layout(
        yaxis_title=dict(text="Cumulative Return", font=dict(size=12)),
        xaxis_title=dict(text="Date", font=dict(size=12)),
        template="plotly_white",
        margin=dict(l=10, r=50, t=50, b=10),
        height=240,
        legend=dict(
            orientation='h',
            x=0,
            y=0.9,
            traceorder='normal',
            font=dict(size=10)
        ),
        xaxis=dict(
            rangeslider=dict(
                visible=True,
                bgcolor='lightgrey',
                thickness=0.05
            )
            
        )
    )

    fig.add_annotation(
        text=f"{ticker_string} vs S&P 500 (Cumulative Return)",
        xref="paper", yref="paper",
        x=0.5, y=1.4,
        showarrow=False,
        font=dict(size=25),
        xanchor='center'
    )

    return dcc.Graph(figure=fig)


def plot_vs_index_gauge(combined, ticker_string):

    last_day = combined.dropna().iloc[-1]
    stock_col = f"{ticker_string} Cumulative"
    last_stock = last_day[stock_col]
    last_sp500 = last_day['S&P 500 Cumulative']

    percent_diff_vs_index = ((last_stock - last_sp500) / last_sp500) * 100

    fig = go.Figure(go.Indicator(
        mode="gauge+number+delta",
        value=percent_diff_vs_index,
        delta={
            "reference": 0,
            "increasing": {"color": color[ticker_string][8]},
            "decreasing": {"color": color[ticker_string][9]}
        },
        gauge={
            'axis': {'range': [-50, 50], 'tickwidth': 1, 'tickcolor': 'darkgrey'},
            'bar': {'color': color[ticker_string][10]},
            'bgcolor': "white",
            'steps': [
                {'range': [-50, 0], 'color': color[ticker_string][11]},
                {'range': [0, 50], 'color': color[ticker_string][12]}
            ],
            'threshold': {
                'line': {'color': "black", 'width': 4},
                'thickness': 0.75,
                'value': percent_diff_vs_index
            }
        },
        domain={'x': [0, 1], 'y': [0.15, 1]},
    ))

    fig.add_annotation(
        text=f"{ticker_string} vs S&P 500 Today",
        x=0.5,
        y=0.05,
        xref="paper",
        yref="paper",
        showarrow=False,
        font=dict(size=12),
        xanchor='center'
    )

    fig.update_layout(
        margin=dict(t=40, b=40, l=40, r=40),
        height=240
    )

    return dcc.Graph(figure=fig)


def closing_price_plot(ticker, ticker_string):
    
    df = ticker.history(period="1d", interval="1m")
    hist = ticker.history(period="10d")

    hist['Percent Change'] = hist['Close'].pct_change() * 100

    hist = hist.reset_index()

    pct_fig = px.line(hist, x='Date', y='Close', color_discrete_sequence=[color[ticker_string][15]])

    for i, row in hist.iterrows():
        if pd.notna(row['Percent Change']):
            pct_fig.add_annotation(
                x=row['Date'],
                y=row['Close'],
                text=f"{row['Percent Change']:.2f}%",
                showarrow=True,
                arrowhead=1,
                ax=0,
                ay=-20
            )

    pct_fig.update_layout(yaxis_title='Price (USD)')


    pct_fig.update_layout(
        yaxis_title=dict(text='Price (USD)', font=dict(size=12)),
        xaxis_title=dict(text="Date", font=dict(size=12)),
        template="plotly_white",
        margin=dict(l=60, r=10, t=50, b=10),
        height=240,
        legend=dict(
            orientation='h',
            x=0,
            y=0.9,
            traceorder='normal',
            font=dict(size=10)
        ),        xaxis=dict(
            tickfont=dict(size=11),
            showgrid=True, gridcolor='lightgrey',
            rangeslider=dict(visible=True, bgcolor='lightgrey', thickness=0.05),
        )
    )

    pct_fig.add_annotation(
        text=f"Closing Prices with Daily % Change",
        xref="paper", yref="paper",
        x=0.5, y=1.4,
        showarrow=False,
        font=dict(size=25),
        xanchor='center'
    )

    plot = dcc.Graph(figure=pct_fig)
    
    return plot

def get_today_change_guage(ticker, ticker_string):
    
    df = ticker.history(period="1d", interval="1m")
    if not df.empty and len(df) > 1:
        open_price = df['Close'].iloc[0]
        latest_price = df['Close'].iloc[-1]
        percent_change_today = ((latest_price - open_price) / open_price) * 100
    else:
        percent_change_today = 0  


    gauge_fig = go.Figure(go.Indicator(
        mode="gauge+number+delta",
        value=percent_change_today,
        delta={"reference": 0, "increasing": {"color": color[ticker_string][8]}, "decreasing": {"color": color[ticker_string][9]}},
        gauge={
            'axis': {'range': [-5, 5], 'tickwidth': 1, 'tickcolor': 'darkgrey'},
            'bar': {'color': color[ticker_string][10]},
            'bgcolor': "white",
            'steps': [
                {'range': [-5, 0], 'color': color[ticker_string][11]},
                {'range': [0, 5], 'color': color[ticker_string][12]}
            ],
            'threshold': {
                'line': {'color': "black", 'width': 4},
                'thickness': 0.75,
                'value': percent_change_today
            }
        },
        domain={'x': [0, 1], 'y': [0.15, 1]},  
    ))

    gauge_fig.add_annotation(
        text="% Change Today",
        x=0.5,
        y=0.05,
        xref="paper",
        yref="paper",
        showarrow=False,
        font=dict(size=12),
        xanchor='center'
    )

    gauge_fig.update_layout(
        margin=dict(t=40, b=40, l=40, r=40),
        height=240, 
    )

    plot = dcc.Graph(figure=gauge_fig)
    
    return plot


def get_volume_plot(df, ticker_string):
    
    volume_fig = px.line(df, x='Date', y=f'Volume_{ticker_string}', template='plotly_white', color_discrete_sequence=[color[ticker_string][16]])
    volume_fig.update_layout(height=240, margin=dict(t=40, b=40, l=40, r=40))


    volume_fig.add_annotation(
        text=f"Daily Trading Volume",
        xref="paper", yref="paper",
        x=0.5, y=1.2,
        showarrow=False,
        font=dict(size=25),
        xanchor='center'
    )
    volume_fig.update_layout(xaxis=dict(
            tickfont=dict(size=11),
            showgrid=True, gridcolor='lightgrey',
            rangeslider=dict(visible=True, bgcolor='lightgrey', thickness=0.05),
            rangeselector=dict(
                buttons=[
                    dict(count=1, label="1m", step="month", stepmode="backward"),
                    dict(count=6, label="6m", step="month", stepmode="backward"),
                    dict(count=1, label="1y", step="year", stepmode="backward"),
                    dict(step="all")
                ],
                x=0.1, xanchor="center",
                y=1.2, yanchor="top",
                font=dict(size=8)
            )
        ))

    plot_volume = dcc.Graph(figure=volume_fig)
    
    return plot_volume

def plot_predicted_volume_gauge(model, df, ticker_string):


    predicted_volume = model.predict([[df.index[-1] + 1]])[0][0]

    volume_col = f'Volume_{ticker_string}'
    max_volume = df[volume_col].max()
    latest_volume = df[volume_col].iloc[-1]

    fig = go.Figure(go.Indicator(
        mode="gauge+number+delta",
        value=predicted_volume,
        delta={
            "reference": latest_volume,
            "increasing": {"color": color[ticker_string][8]},
            "decreasing": {"color":color[ticker_string][9]}
        },
        gauge={
            'axis': {'range': [0, max_volume], 'tickwidth': 1, 'tickcolor':'darkgrey'},
            'bar': {'color': color[ticker_string][10]},
            'bgcolor': "white",
            'steps': [
                {'range': [0, max_volume * 0.5], 'color': color[ticker_string][11]},
                {'range': [max_volume * 0.5, max_volume], 'color': color[ticker_string][12]}
            ],
            'threshold': {
                'line': {'color': "black", 'width': 4},
                'thickness': 0.75,
                'value': predicted_volume
            }
        },
        domain={'x': [0, 1], 'y': [0.15, 1]}
    ))

    fig.add_annotation(
        text="Trading Volume for Tomorrow",
        x=0.5,
        y=0.05,
        xref="paper",
        yref="paper",
        showarrow=False,
        font=dict(size=12),
        xanchor='center'
    )

    fig.update_layout(
        margin=dict(t=40, b=40, l=40, r=40),
        height=240
    )

    return dcc.Graph(figure=fig)



ticker_dropdown = dcc.Dropdown(
    id='ticker-dropdown',
    options=[
        {'label': 'Apple', 'value': 'AAPL'},
        {'label': 'Microsoft', 'value': 'MSFT'},
        {'label': 'Google', 'value': 'GOOGL'},
        {'label': 'Amazon', 'value': 'AMZN'},
        {'label': 'Tesla', 'value': 'TSLA'},
        {'label': 'Meta', 'value': 'META'},
    ],
    value='AAPL',
    clearable=False,
    style={'width': '200px'}
)

update_button = dbc.Button("Update", id="update-button", style={'background-color': "black", 'color': "white"}, className="ms-2")

